---
title: "A dynamic Dumbell plot made with flexdashboard"
author: "SM"
date: "`r format(Sys.time(), '%d-%m-%Y')`"
output:
    flexdashboard::flex_dashboard:
        theme: default      # Available themes: default, cerulean, journal, flatly, darkly, readable, spacelab, united, cosmo, lumen, paper, sandstone, simplex, yeti.
        orientation: columns
        vertical_layout: fill
        # storyboard: true
runtime: shiny
# runtime: shiny_prerendered
---


```{r setup, include = FALSE}
#---------------------------------------
# Required libraries
#---------------------------------------
library(tidyverse)      # load all tidyverse stuff
library(lubridate)      # tidy management of date and time

library(flexdashboard)
#---------------------------------------
```

```{r global, include = FALSE}

# all expensive work should go here

#---------------------------------------
# Constants
#---------------------------------------
# OS-specific constants
SEPARATOR <- .Platform$file.sep

# define the current directory, i.e., the directory that contains the source files
SRC  <- getwd()

# the main project directory is the parent of the source directory
PROJECT <- file.path(SRC, "..") %>% normalizePath()

# define main directory contining all data files
DATA <-  file.path(PROJECT, "dati")

# define directories for output files (e.g., reports and plots) 
# (they can be created later if they do not already exist)
OUTPUT <-  file.path(PROJECT, "dati")

# set timezone
Sys.setenv(TZ = "CET")
#---------------------------------------


#---------------------------------------
# User-defined parameters
#---------------------------------------

csv_filename <- "dati.csv"
xls_filename <- "dati.xlsx"
sheet_main <- "Foglio 1"
# skip_main <- 2
#---------------------------------------


#---------------------------------------
# Functions
#---------------------------------------

# fix names of dataframe columns
fix_column_names <- function(df) {
    df_names <- names(df)
    fixed_names <- df_names %>%
        str_replace("[.]", "_")

    names(df) <- fixed_names

    return(df)
}
#---------------------------------------

# fix formats of dataframe columns
fix_column_formats <- function(df) {
    
    # convert all columns containing dates to the proper <date> format
    df$Decorrenza_contratto <- df$Decorrenza_contratto %>% lubridate::dmy()
    df$Scadenza_contratto   <- df$Scadenza_contratto   %>% lubridate::dmy()
    df$Data_inizio <- df$Data_inizio %>% lubridate::my()
    df$Data_fine   <- df$Data_fine   %>% lubridate::my()

    # convert colum "Stato" to the factor format
    df$Stato <- df$Stato %>% as.factor()
    
    return(df)
}
#---------------------------------------

# define new columns
def_columns <- function(df) {
    # define a column  by merging "Cliente" and "Servizio"
    df <- df %>% mutate(CS = paste("Cliente", Cliente, "-", "servizio", Servizio), .keep = "all") %>% 
    relocate(CS, .before = Cliente)
    df$CS <- df$CS %>% forcats::as_factor() %>% forcats::fct_rev()

    # define a column containg the last day of the month associated to the "Data_fine" field
    df$Data_fine_last_day <- lubridate::ceiling_date(df$Data_fine, "month") - days(1)

    return(df)
}
#---------------------------------------


#---------------------------------------
# Read data file and clean/fix data
#---------------------------------------
input_file <- file.path(DATA, csv_filename)
# df <- read.csv(input_file, , header = TRUE, strip.white = TRUE) %>% as_tibble()

fileData <- reactivePoll(1000, NULL,
    checkFunc = function() {
        if (file.exists(input_file))
            file.info(input_file)$mtime[1]
        else
            ""
    },
    valueFunc = function() {
        ddf <- read.csv(input_file, header = TRUE, strip.white = TRUE)
        ddf <- fix_column_names(ddf)
        ddf <- fix_column_formats(ddf)
        ddf <- def_columns(ddf)

        return(ddf)
    }
    )


# df_names <- names(df)
# fixed_names <- df_names %>%
#     str_replace("[.]", "_")
#
# names(df) <- fixed_names
#
# # convert columns containing dates to <date> format
# df$Decorrenza_contratto <- df$Decorrenza_contratto %>% trimws() %>% lubridate::dmy()
# df$Scadenza_contratto   <- df$Scadenza_contratto   %>% trimws() %>% lubridate::dmy()
# df$Data_inizio <- df$Data_inizio %>% trimws() %>% lubridate::my()
# df$Data_fine   <- df$Data_fine   %>% trimws() %>% lubridate::my()
# df$Data_fine_last_day <- lubridate::ceiling_date(df$Data_fine, "month") - days(1)
#
# # convert colum Stato to a factor
# df$Stato <- df$Stato %>% trimws() %>% as.factor()
#
#
# # create new column merging Cliente and Servizio
# df <- df %>% mutate(CS = paste("Cliente", Cliente, "-", "servizio", Servizio), .keep = "all") %>%
#     relocate(CS, .before = Cliente)
# #df
#
# df$CS <- df$CS %>% forcats::as_factor() %>% forcats::fct_rev()

#---------------------------------------
```

## Input {.sidebar}

```{r}
# # set range of dates to be shown in input sidebar
# expr_min <- quote({
#     min(fileData()$Data_inizio) %>% lubridate::year() %>% paste0("01-01-", .) %>% lubridate::dmy() %>% as.character()
#     })
# expr_max <- quote({
#     max(fileData()$Data_fine) %>% lubridate::year() %>% paste0("31-12-", .) %>% lubridate::dmy() %>% as.character()
#     })
# min_date <- reactive(expr_min, quoted = TRUE)
# max_date <- reactive(expr_max, quoted = TRUE)


# chaining after an arithmetic operation requires the expression to be wrapped in braces 
start_date <- Sys.Date() %>% {lubridate::year(.) - 2} %>% as.character() %>% paste0("01-01-", .) %>% lubridate::dmy() %>% as.character()
end_date <- Sys.Date() %>% {lubridate::year(.) + 1} %>% as.character() %>% paste0("31-12-", .) %>% lubridate::dmy() %>% as.character()


# # set range of dates to be shown in input sidebar
# min_date <- min(fileData()$Data_inizio) %>% lubridate::year() %>% paste0("01-01-", .) %>% lubridate::dmy() %>% as.character() %>% reactive()
# max_date <- max(fileData()$Data_fine) %>% lubridate::year() %>% paste0("31-12-", .) %>% lubridate::dmy() %>% as.character() %>% reactive()
#
# # dmin <- min_date()
# # dmax <- max_date()


# here the isolate() function allows to use a reactive variable as a parameter
dateRangeInput("daterange", label = "Seleziona qui la data iniziale e la data finale da visualizzare:", 
               start = start_date, end = end_date,
               format = "dd-mm-yyyy", language = "it", separator = " a ",
               startview = "year"
    )

# observe({
#     dmin <- min_date()
#     dmax <- max_date()
#     updateDateRangeInput(session = getDefaultReactiveDomain(), "daterange", start = min_date(), end = max_date())
# })

# renderPrint(min_date())
# renderPrint(max_date())

```

::: usage
Il grafico mostra la data iniziale e finale di ogni contratto stabilito con i clienti, indicandone anche lo stato attuale (già pagato, prossima scadenza, da pagare).
:::

```{r}
# not used yet but still nice to have
## actionButton("update", "Update plot", class = "btn btn-primary", icon("person-running"))

```

## Column {.tabset}

### Dynamic Chart 

```{r}
renderPlot({
    p <- ggplot(data = fileData()) + 
        geom_segment(aes(x = Data_inizio, xend = Data_fine_last_day, y = CS, yend = CS), linewidth = 0.0) +
        geom_rect(aes(xmin = Data_inizio, xmax = Data_fine_last_day, ymin = as.numeric(CS) - 0.1, ymax = as.numeric(CS) + 0.1, fill = Stato), color = "black") +
        geom_text(aes(x = Data_inizio, y = as.numeric(CS), label = Label), color = "black", 
                  hjust = "left", nudge_x = 5, 
                  vjust = "bottom", nudge_y = 0.25) +
        scale_x_date(date_breaks = "3 months", date_labels = "%m-%y", minor_breaks = "1 month", 
        limits = input$daterange %>% as.Date(origin = "1970-01-01") %>% lubridate::ymd(), 
        expand = c(0, 0), position = "bottom") +
    labs(x = "Data") + 
    theme_minimal() + 
    theme(axis.text = element_text(size = 14),
          axis.title.x = element_blank(), 
          axis.title.y = element_blank(), 
          panel.grid.major.x = element_line(linewidth = 0.2,  color = "black"),
          panel.grid.minor.x = element_line(linewidth = 0.1, color = "gray"),
          legend.position = "bottom"
          )
    p
})
```

### Data table {data-width="50%"}
```{r}
# renderTable({fileData()}, striped = TRUE, hover = TRUE, bordered = TRUE)
# renderDataTable({fileData()})
renderTable({fileData() %>% 
        select(!c(CS, Data_fine_last_day)) %>% 
        mutate(
            across(matches(c("Data", "contratto")), stamp("31-12-1970")),
            across(matches(c("Data", "contratto")), as.character)
            )
    }, striped = TRUE, hover = TRUE, bordered = TRUE, width = "100%",)
```


### Info
::: card
Il diagramma detto di Dumbbell è un tipo di grafico nel quale i due punti estremi di ciascun gruppo sono collegati da linee rette. Questo grafico può essere utilizzato per visualizzare come cambia una variabile in due diversi istanti di tempo o per mostrare l'intervallo di variazione di una variabile tra diversi gruppi. 

Ad esempio, può essere usato per indicare la crescita della popolazione in due anni diversi in diversi Paesi o la differenza tra i clienti attuali e potenziali di diverse aziende.

In questo caso specifico, il grafico mostra la data iniziale e finale di ogni contratto stabilito con i clienti, indicando anche lo stato (già pagato, prossima scadenza, da pagare) del contratto stesso.

:::
